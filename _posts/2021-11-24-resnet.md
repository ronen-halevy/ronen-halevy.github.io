---
title: Resnet - Deep Residual Learning for Image Recognition
tags:  ImageDetection ImageSegmentation Guides
---

<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-kusv{background-color:#fffe65;border-color:inherit;text-align:left;vertical-align:top}
.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}
</style>
<table class="tg">
<thead>
  <tr>
    <th class="tg-0pky">layer_name</th>
    <th class="tg-0pky">stride</th>
    <th class="tg-0pky">up-sample</th>
    <th class="tg-0pky">input size</th>
    <th class="tg-0pky">outout size</th>
    <th class="tg-0pky">kernel</th>
    <th class="tg-0pky">output channels</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0pky">conv1</td>
    <td class="tg-0pky">2</td>
    <td class="tg-0pky">1</td>
    <td class="tg-0pky">224 x 224</td>
    <td class="tg-0pky">112 x 112</td>
    <td class="tg-0pky">7x7</td>
    <td class="tg-0pky">64</td>
  </tr>
  <tr>
    <td class="tg-kusv" rowspan="2"><br><br>conv2.1</td>
    <td class="tg-kusv">2</td>
    <td class="tg-kusv">1</td>
    <td class="tg-kusv">112x112</td>
    <td class="tg-kusv">56x56</td>
    <td class="tg-kusv">maxpool 3x3</td>
    <td class="tg-kusv">64</td>
  </tr>
  <tr>
    <td class="tg-kusv">1</td>
    <td class="tg-kusv">1</td>
    <td class="tg-kusv">56x56</td>
    <td class="tg-kusv">56x56</td>
    <td class="tg-kusv">3x3</td>
    <td class="tg-kusv">64</td>
  </tr>
  <tr>
    <td class="tg-kusv">conv2.x</td>
    <td class="tg-kusv">1</td>
    <td class="tg-kusv">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x3<br></td>
    <td class="tg-kusv">56x56,64}<br>28x28,64}</td>
    <td class="tg-kusv">56x56</td>
    <td class="tg-kusv">3x3</td>
    <td class="tg-kusv">64</td>
  </tr>
  <tr>
    <td class="tg-kusv" rowspan="2">x2<br><br>conv2.3-conv2.6</td>
    <td class="tg-kusv">1</td>
    <td class="tg-kusv">1</td>
    <td class="tg-kusv">56x56</td>
    <td class="tg-kusv">56x56</td>
    <td class="tg-kusv">3x3</td>
    <td class="tg-kusv">64</td>
  </tr>
  <tr>
    <td class="tg-kusv">1</td>
    <td class="tg-kusv">1</td>
    <td class="tg-kusv">56x56<br></td>
    <td class="tg-kusv">56x56</td>
    <td class="tg-kusv">3x3</td>
    <td class="tg-kusv">64</td>
  </tr>
  <tr>
    <td class="tg-0pky" rowspan="2"><br>conv3.x<br></td>
    <td class="tg-0pky">2</td>
    <td class="tg-0pky">2</td>
    <td class="tg-0pky" rowspan="2"><br>56x56}<br>28x28}</td>
    <td class="tg-0pky">28x28</td>
    <td class="tg-0pky">3x3</td>
    <td class="tg-0pky">128</td>
  </tr>
  <tr>
    <td class="tg-0pky">1</td>
    <td class="tg-0pky">1</td>
    <td class="tg-0pky">28x28</td>
    <td class="tg-0pky">3x3</td>
    <td class="tg-0pky">128</td>
  </tr>
  <tr>
    <td class="tg-0pky" rowspan="2">x3<br><br>conv3.3-conv3.8</td>
    <td class="tg-0pky">1</td>
    <td class="tg-0pky"></td>
    <td class="tg-0pky">yyy</td>
    <td class="tg-0pky"></td>
    <td class="tg-0pky"></td>
    <td class="tg-0pky"></td>
  </tr>
  <tr>
    <td class="tg-0pky"></td>
    <td class="tg-0pky"></td>
    <td class="tg-0pky"></td>
    <td class="tg-0pky"></td>
    <td class="tg-0pky"></td>
    <td class="tg-0pky"></td>
  </tr>
  <tr>
    <td class="tg-0pky">conv4.1</td>
    <td class="tg-0pky">2</td>
    <td class="tg-0pky">2</td>
    <td class="tg-0pky">28x28</td>
    <td class="tg-0pky">14x14</td>
    <td class="tg-0pky">3x3</td>
    <td class="tg-0pky">256</td>
  </tr>
  <tr>
    <td class="tg-0pky">conv4.2</td>
    <td class="tg-0pky">1</td>
    <td class="tg-0pky">1</td>
    <td class="tg-0pky">14x14</td>
    <td class="tg-0pky">14x14</td>
    <td class="tg-0pky">3x3</td>
    <td class="tg-0pky">256</td>
  </tr>
  <tr>
    <td class="tg-0pky">conv5.1</td>
    <td class="tg-0pky">2</td>
    <td class="tg-0pky">2</td>
    <td class="tg-0pky">14x14</td>
    <td class="tg-0pky">7x7</td>
    <td class="tg-0pky">3x3</td>
    <td class="tg-0pky">512</td>
  </tr>
  <tr>
    <td class="tg-0pky">conv5.2</td>
    <td class="tg-0pky">2</td>
    <td class="tg-0pky">2</td>
    <td class="tg-0pky">7x7</td>
    <td class="tg-0pky">7x7</td>
    <td class="tg-0pky">3x3</td>
    <td class="tg-0pky">512</td>
  </tr>
  <tr>
    <td class="tg-0pky" rowspan="2"><br>FC</td>
    <td class="tg-0pky">2</td>
    <td class="tg-0pky">1</td>
    <td class="tg-0pky">7x7</td>
    <td class="tg-0pky">512</td>
    <td class="tg-0pky">Global<br>average pool<br></td>
    <td class="tg-0pky">512</td>
  </tr>
  <tr>
    <td class="tg-0pky" colspan="2"></td>
    <td class="tg-0pky">512</td>
    <td class="tg-0pky">1000</td>
    <td class="tg-0pky"></td>
    <td class="tg-0pky">-</td>
  </tr>
  <tr>
    <td class="tg-0pky">FLOPS</td>
    <td class="tg-0pky" colspan="6">3.6 x 10e9</td>
  </tr>
</tbody>
</table>


## Introduction

The Background for proposing this Neural Network model, was the challenge of implementing deeper CNNs to achieve better classification performance. Deeper CNNs resulted with improved performance. This is valid for a various of computer vision tasks such as recognition, detction, segmentation etc. On the other hand, when getting much deeper, problems such as vanishing/exploding gradients become more significant, with symptoms such as growing errors and accuracy degradation. 

In their paper from 2015, ["Deep Residual Learning for Image Recognition"](https://arxiv.org/abs/1512.03385), Kaiming He, Xiangyu Zhang, Shaoqing Ren & Jian Sun proposed a model which enables the training very deep networks - the Resnet. The paper demonstrates Resnet-34, Resnet-50, Resnet-101 and Resnet-152, which deploy 34, 50, 101 and 152 parametric layers respectively.

## Resnet Functional Description

Resnet building block is called a `Residual Block` which contains a `skip` connection, aka a `short-cut` as depicted in Figure 1 and described next.



***Figure 1: Resnet Residual Block***

![Resnet Residual Block]({{ site.baseurl }}/assets/images/cnn-models/resnet-residual-block.drawio-n.png)




As shown by Figure 1, the skip is added to plain connection just before the Relu module, thus providing nolinearity effect to the sum. Note that each conv element is followed by a back normalization module and a ReLu activation module.
Note - the values of the stride s and the down-scale parameter d are discussed later.

A Resnet network stacks Residual Blocks back to back, as illustrated by Figure 2. 

***Figure 2: Resnet-18***

![Resnet Residual Block]({{ site.baseurl }}/assets/images/cnn-models/resnet-18-block-diagram.drawio.png)


Figure 2 depicts a Resnet-18 CNN, named so for the 18 layers. The last layer is an FC (fully connected) layer, which receives the flatten array of data and outputs N recognition classes through a softmax module. Resnet was evaluatedwith ImageNet 2012 classification dataset that consists 1000 classes.


## Bottle-neck Resnet

Obviously, yhe deeper the resnet is, the more computation operations are needed - those are counted as FLOPS, where each FLOP is an add/multiply operation.
To cope with that, deeper networks, from Resnet50 and up, replace the Resnet Residual block by a Bottlenek Resnet block, as depicted by Figure 3.


***Figure 3: Bottlenek Resnet Block***

![Resnet Residual Block]({{ site.baseurl }}/assets/images/cnn-models/rdeeper-bottleneck-resnet-residual.drawio.png)

The bottleneck block consists of 3 conv blocks: A single conv 3 x 3, wrapped between 2 conv 1 x 1 blocks. Comparing to the basic Residual Block, this one uses a single conv 3 x 3 module. Note that the conv 3 x 3 requires 9 times more FLOPS than a conv 1 x 1. The conv 3 x 3 is indeed named the `bottleneck`. The front conv 1 x 1 module scales dimenssions down, to offload the bottleneck, while the conv 1 x 1 scales it up.





## Dimenssions Matching






## Notes on Vanishing Gradient problem

***A brief reminder of vanishing gradient problem*** - during the backpropagation, the network's weights parameters are gradually updated to minimize the loss function, according to Gradient Descent algorithm - or any of its variants.

Here's the Gradient Descent update equation, for uptating the weights of the kth layer at time \\(i+1\\):

$w_{i+1}^k=w_i^k+\alpha * \frac{d L}{dw_i^k} $


Where:

- \\(w_{i+1}^k\\) expresses the kth layer's weights at time \\(i+1\\).
- \\(\alph\\) is the learning rate
- \frac{d L}{dw_i^k} is the Loss gradient with respect to the weight at time \\(i+1\\).


The gradients are calculated using the derivative chain rule, where the optimization calculation is executed in a back propogating manner, starting from layer k=L, back till k=1. 

Let's illustrate the back propogation on a residual block, i.e. the Loss derivative with respect to \\(a^{k}\\), given \\(\frac{dL}{da^{(k+2)}}\\). 

See Diagram below, which is followed by the xhin rule detivative expression.

![Resnet Residual Block](https://github.com/ronen-halevy/ronen-halevy.github.io/blob/master/assets/images/cnn-models/chain-rule-resnet-stack-of-residual-block.drawio.png)

According to chain rule:

\\(\frac{dL}{da^{(k)}} =  \frac{dL}{da^{(k+2)}}\frac{da^{(k+2)}}{da^{(k)}}\\)

Consider that:

\\(a^{(k+2)}} =  g(F(a^{(k)}) +  a^{(k)})


Where g(x) is the activation function, ReLu in this example. ReLu is linear for positive arguments and zero otherwise, so let's concentrate on the nonw zero case.

In that case, the derivative of the `skipped` component is 1, so this component protects against vanishing gradient problem.

## Notes on Dimenssions Matching

If the dimenssions of the plain section increae, so it now differs from the skip input dimenssions, 2 approaches can be taken:
1. Add extra zero padding to the skip data.
2. Use projection, i.e. convolve with 1 x 1 kernel, just to expand dimensions.

Besides improving vanishing gradients issue, the `skip` connections carry lower level information from initial layers which correspnd to lower level features. 
Adding this information to the higher level more abstract information extracted by the layers which follow, contributes to better performance.
